/**
 * HTML via Java(tm) Language Bindings
 * Copyright (C) 2013 Jaroslav Tulach <jaroslav.tulach@apidesign.org>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details. apidesign.org
 * designates this particular file as subject to the
 * "Classpath" exception as provided by apidesign.org
 * in the License file that accompanied this code.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. Look for COPYING file in the top folder.
 * If not, see http://wiki.apidesign.org/wiki/GPLwithClassPathException
 */
package net.java.html.json;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/** The threading model of classes generated by {@link Model @Model} requires
 * that all operations are perform from the originating thread - unless they
 * are invoked as {@link ModelOperation @ModelOperation} methods.
 * <p>
 * A method in a class annotated by {@link Model @Model} annotation may be
 * annotated by {@link ModelOperation @ModelOperation}. The method has
 * to be static, non-private and return <code>void</code>. The first parameter
 * of the method must be the {@link Model#className() model class} followed
 * by any number of additional arguments.
 * <p>
 * As a result method of the same name and the same list of additional arguments
 * (e.g. without the first model class one) will be generated into the 
 * {@link Model#className() model class}. This method can be invoked on any
 * thread, any time and it is the responsibility of model manipulating
 * technology to ensure the model is available and only then call back to 
 * the original method annotated by {@link ModelOperation @ModelOperation}.
 * The call may happen synchronously (if possible), or be delayed and invoked
 * later (on appropriate dispatch thread), without blocking the caller.
 * <pre>
 * 
 * {@link Model @Model}(className="Names", properties={
 *   {@link Property @Property}(name = "names", type=String.class, array = true)
 * })
 * static class NamesModel {
 *   {@link ModelOperation @ModelOperation} static void <b>updateNames</b>(Names model, {@link java.util.List}<String> arr) {
 *     <em>// can safely access the model</em>
 *     model.getNames().addAll(arr);
 *   }
 * 
 *   static void initialize() {
 *     final Names pageModel = new Names();
 *     pageModel.applyBindings();
 * 
 *     <em>// spawn to different thread</em>
 *     {@link java.util.concurrent.Executors}.newSingleThreadExecutor().execute({
 *       List<String> arr = <em>// ... obtain the names somewhere from network</em>
 *       pageModel.<b>updateNames</b>(arr);
 *       // returns immediately, later it invokes the model operation
 *     });
 * 
 *   }
 * }
 * 
 * @author Jaroslav Tulach <jtulach@netbeans.org>
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface ModelOperation {
}
